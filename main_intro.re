={main-intro} Binderの本格的な入門

//lead{
ここからはある程度この分野に慣れている人を対象に、Binderとその主たる応用例となるシステムサービスの詳細をしっかりと理解していくという内容となります。
本節では以降の節全体をまとめた全体像の提示や、
以後の節を読んで行く為の導入として、Binderの詳細を理解する意義や想定する前提知識の話をしていきます。

なお、本書ではドライバ名としては小文字のbinderを、Binderという仕組み全体を表す時は大文字始まりのBinderを使っていきます。
//}

== Binderとシステムサービスを詳細に理解する意義

@<chapref>{intro}の内容で、他の章を読んだりソースコードを読んでいく分には十分と言いました。
それでは以後の長い本章の内容は何故あるのか？という話を最初にしたいと思います。

Binderを詳細に理解していく意義としては、以下のような物があると思っています。

 1. ソースコードを読んでいてBinderが登場しても、全てを正確に理解出来る
 2. システムサービスのメソッド呼び出しをカーネルのコンテキストスイッチのレベルで理解出来る
 3. 全てのコードが公開されている、世界中で日々使われている分散オブジェクトのシステムを学習出来る
 4. AndroidのAndroidらしさを知る手がかりとなる

(1) 1が一番大きな所だと思います。Androidというシステムのソースコードを調べていく時に、
「ここから先は分からない…」と毎回壁となってしまうのが、このBinder周辺だと思います。
それは本章がこれだけ長い事からも分かる通り、やろうとしている事が単純な割にはソースコードで知らなくてはいけない事が多いからです。
調べたい本題が別にある状態でこのBinderのソースの深い森に遭遇してしまうと、
どうしてもそれを最後まで読み切るのは難しく、いつもこの森の前まででソース読みを終える事になってしまいます。

実際のプロダクションの現場において、この森の手前までの調査で困る事はおそらくほとんど無いと思います。
ですから仕事で飯を食べるだけなら、多くのプログラマはこの手前まででも十分でしょう。

でもAndroidがこれまでの携帯電話のシステムと比較して最も新しかった点は、
携帯電話のシステムとしては信じられないくらいオープンだった事です。
せっかく全てのソースコードが公開されているのですから、Androidを楽しみ尽くす為には、
ソースは全て理解出来る方が絶対に良いと思います。

全てを理解しよう、と思った時に大きな壁として立ちはだかるBinder周辺の全構造がちゃんと解説されている本章は、
Androidを楽しもう、と思う読者には、大きな助けとなると思います。

(2) システムサービスの呼び出しなどに代表されるBinder越しの呼び出しで、実際に何が起こっているのかをカーネルのコンテキストスイッチのレベルで理解出来る、
というのは、システムを深く理解する立場からすると重要になります。
コンテキストスイッチのレベルから分かる事で、汚されるキャッシュやTLBエントリなど、
既にベテランのデベロッパが知っている多くの周辺知識が使えるようになります。

最終的なパフォーマンスは計測の必要がありますが、
Androidのシステム構成がどの位重そうか、という感覚が分かるようになります。

(3) この3だけはちょっと変わった視点で、分散オブジェクトのシステムの勉強としての視点となります。
複雑になりがちな分散オブジェクトシステムですが、Binderは他のシステムと比べるとローカルだけを前提としていて、
使われる環境もAndroidだけをターゲットにしているので非常にコンパクトなシステムです。
そうでありながらおもちゃの分散オブジェクトシステムとは違いプロダクションで最も良く使われている分散オブジェクトシステムの一つと言えるくらい使われていて、
しかも現在でも使われ続けている現代のシステムとして、十分な実績があります。

実績のある分散オブジェクトシステムを学ぼうとすると間の抽象化レイヤが多すぎてなんだかぼやっとした理解にとどまってしまう事が多いと思いますが、
Binderは抽象化を極限までしない実装となっているため、一人の人間が隅から隅まで理解出来るシステムとなっています。
分散オブジェクトを本格的に学ぶ最初のシステムとしては、最も良い教材と思います。

(4) 最後は上三つと比べると少し抽象的な話となりますが、
BinderはAndroidというシステムのプロセス構成という、
モバイルOSとしての立ち位置を考える時にキーとなる部分をつかさどる技術となっています。

モバイルのOSとしては全て単一のプロセス内で構築する原始的なRTOSのような物から、
全てプロセスを分けるマイクロカーネル的な物までいろいろと考えられます。
そして多くのシステムで全てを別プロセスにするのは重すぎるため、アプリはdllにしたりと言った工夫が見られます。

AndroidではBinderという物を導入する事でモバイルOSとしては旧来と同程度に貧弱なリソース（か少しリッチな程度）のデバイスでも動きつつ、
将来的にはプロセスを分けていきよりリッチなデバイスで高パフォーマンスなシステムとしていく、という進化の道筋を最初につけておいたのが特徴的です。

Binderを詳細に理解しておくと、この辺のバランス感覚を知る事が出来て、
ひいてはAndroidのAndroidらしさ、のような物を知る事が出来ます。
こうした哲学や「らしさ」という要素は、一段深いAndroidという物の理解を生むと同時に、
何故いろいろある中でAndroidだったのか？と言ったより難しい問への答えを自分の中で探す時の手掛かりとなります。

===[column] 分散オブジェクトとマイクロカーネルの夢
私的な話となりますが、著者の私はCOMなどの分散オブジェクト技術が好きな方です。
COMには若いころ結構な時間をかけて学んだ思い出があります。

カーネルを小さく保って最初からオブジェクト指向ベースのOSを作る、
というのは結構多くの人が夢見た所で、私も若いころはMSRのMMLiteなどのような同コンセプトのシステム資料を見ては胸躍らせた時代があります。

Binderの起源となったBeOSについては、私はあまり詳しくありませんが、
同様にマイクロカーネルでオブジェクト指向ベースなシステムだったと理解しています。
そのBeOSのBinderを元にLinuxというマイクロカーネルと正反対のカーネルが組み合わさって、
分散オブジェクトベースのシステムでありながら現実の数々の問題を解決している、
というバランス感覚は、夢見る青二才とは格の違う真のOSアーキテクトの凄みを感じさせる部分だと思っています。

Honeycombの頃などにその設計思想を活かして現代的なGUIシステムへと変貌していくさまをリアルタイムで見ていた私は、
久しぶりに若いころの興奮を思い出しました。
===[/column]

== Binderを詳細に理解するのに必要な前提知識

本章の以降の内容では、分散オブジェクトシステムの開発の経験を前提とさせてもらいます。
具体的には

 1. IDLを書いてコンパイルし、スタブの実装を書いてプロキシを使った事がある(またはその意味が分かる)
 2. スタブ、プロキシという言葉を理解している
 3. IPC、RPC、分散オブジェクト、シリアライズといった用語が分かる
 4. C言語などの低レベルの通信層のコードに慣れている（オブジェクトのシリアライズ等）

という位をイメージしています。
昔書いた事はあるが忘れかかっている、という人や、完全に上記条件は満たさないが似たようなシステムを使っている（例: インターフェースからの動的コード生成系のフレームワーク利用者など)人などに向けて、
多少は説明も行いますが、まったく知らない人が上記の事を学ぶには本書は適切では無いと思います。

上記の事を学びたい人は、分散オブジェクトの入門書などを学ぶのが良いと思います@<fn>{dobj}

//footnote[dobj][今ならgRPCやThriftなどでしょうか。私の頃はCOMで学びました。]


== Binderを構成するレイヤ

分散オブジェクトのシステムは一般に複数のレイヤで実現されていて、
各レイヤでプロキシと実装側のクラスが出てくる事から、
毎回同じようなクラスが出てきて同じような説明をする事になります。

そんな説明を読み続けて行くと、そこで言っている事は理解する事は出来ても、
そもそもなんで今こんな話をしているのか、という事が良く分からなくなっていく事になりがちです。

そこでまずは全体の構成を見てみたいと思います。
以下の各節で何の話か分からなくなった時にはここに戻ってきてみてください。

//image[2_3_1][Binderを構成するレイヤ達]

まず一番下から見ていくと、一番下はbinderドライバとなります。
binderドライバが二つのプロセスの間の通信を担当します。

その上にはスレッドプールを実現するレイヤがあります。@<fn>{layer}
クラスとしてはProcessState、IPCThreadState、BBinder、BpBinder、IBinderです。
//footnote[layer][なお、このレイヤ分けの図も名前も私がソースを読んで決めたもので、公式から発表されている物ではありません。そもそもこの周辺はあまり公式の情報はありません。]

このレイヤで単純なioctlによるプロセス間通信が、
スレッドプールとC++のオブジェクトに対するメッセージ送信、という形へと発展します。
スレッドプールは、その実現でBBinderというオブジェクトの基底クラスとBpBinderというプロキシの基底クラスがやりとりされる、
という前提に基づいる為、これらは合わせて使う必要があります。
この基底クラスで、全てのサービスで共通となるメッセージの処理を行います。

ここまででオブジェクトという対象をやりとりするのですが、
呼び出し側はサービスが自分のプロセスに居るのか別のプロセスに居るのかに応じてコードを変えなくてはいけません。

このスレッドプールのレイヤの上には、それぞれ並行して二つのレイヤが存在しています。
ネイティブとJavaで、呼び出し側コードをサービスがどこのプロセスに居るかを意識せずに使えるようにする為のレイヤです。
共通ネイティブインターフェースのレイヤとAIDLのレイヤはお互い依存していない、独立したレイヤです。
どちらも下のスレッドプールのレイヤを使用しています。

共通ネイティブインターフェースのレイヤは、クラスとしてはIInterface、BnInterface、BpInterfaceの三つのクラスとなります。

AIDLのレイヤはJavaによるサービス実装のレイヤとなります。AIDLからコードを自動生成する仕組みを用いるレイヤで、
主なクラスは生成するインターフェースに応じた名前となる為、図ではIXXXと表記しました。
通常はIAudioServiceなどのような名前となります。

ネイティブでサービスを実装する時はIInterfaceの方を使い、
Javaでサービスを実装する場合はAIDLを使う事になります。

この二つのレイヤが実際にサービスを実装する人が直接用いるレイヤの為、
なるべく実装者が不要なコードを書かなくても済むように自動生成やマクロなどのいろいろなトリックが使われています。
また、実装にはいろいろと慣例があり、その慣例に何も考えずに従って実装すると、
下の方の仕組みがどうなっているか、という事はあまり意識せずに、
分散オブジェクトとしてのシステムサービスが実装出来るようになっています。
開発者があまり良く理解していなくてもとりあえず見様見真似で動くコードが書ける、という訳です。

仕組みとして重要なのはドライバと、その上のスレッドプールのレイヤ、つまりIPCThreadStateやBBinderのレイヤとなります。
そこより上の層は開発者が実際に目にする事は多くとも、実装的には複雑な事はありません。
Binderの全体像をしっかりと把握するためにはbinderドライバとスレッドプールのレイヤををしっかり学ぶ事がポイントとなります。

== 本章の以後の構成

分散オブジェクトの解説をする時に、上からするか下からするかは難しい選択です。

上から解説すると各コードの使われ方が分かるので目的は理解しやすい反面、毎回依存する下のレイヤーはまだ解説されていない状態で現在のレイヤーのコードを理解しないといけない為、
読み手のコードリーディングの慣れを要求します。
一方下から解説すると依存する物は既に説明されたものだけなので説明は全て理解出来る反面、
現在説明している事が何に使われるかが分からないまま説明が続く事になります。

本書では下から順番に解説する事を選びました。
その為説明はそこまでに全て出てきた要素で閉じるため読みやすい反面、
そこのコードがどう使われるかは先を読まないと分からない、という構成になっています。
読んでいて何のために今説明しているコードがあるのか、という事が良く分からなくなったら、
少し先を読んでみてから戻ってくると言っている事が分かる、という事があると思いますので、
そういう読み方をしてみて下さい。


まず@<chapref>{systemcall}、@<chapref>{driver_message}、@<chapref>{flat_binderobj}の三つの節でbinderドライバのレイヤの話をします。
その後@<chapref>{threadpool}でスレッドプールのレイヤを、@<chapref>{common_intr}で共通ネイティブインターフェースのレイヤを扱い、
@<chapref>{java_aidl}でAIDLのレイヤ、つまりJavaによるシステムサービス実装を扱います。

最後に@<chapref>{systemservices}でBinderの仕組みを実際に使っている側に視点を移して、
システムサービス関連のプロセスがどのように動いているか、
他の章でBinderが絡む所をBinder側から見るとどうなるか、
などの他のコンポーネントから見たBinderという位置づけを見ていきます。

なお、本章ではかなり低レベルなコードがたくさん出てきます。その為、少し他の章よりはプログラムを読みなれている人向けになっています。
コードは説明の為に使っているのであって、動く事は意図していません。
たとえば実際には0クリアをしないといけない重要でないフィールドを無視したりしている為、完全に動くコードではありません。

#@# TODO: 章リード文内で、「Binder」「binderドライバ」が少し唐突。システムサービスとBinder/binderドライバの関係を少し噛み砕いて補足。（8.1節のリードなどと重複するかもですが、難しいところなので繰り返し説明があったも良いと思った。あと、章リードの時点で、ドライバと出てくるけど、なぜだろうと、思ったので、補足あったら嬉しい）。
#@# TODO:「Binder」について、XXのためのorXXの用途で使われる（目的/用途）プロセス間通信のしくみです、のような補足が欲しい（8.1.1項で「サービスというプログラミングモデルでシステムを組む為に、それ専用のプロセス間通信の仕組みを作った」とあったが、少し難しかったことと、先に言ったほうがさらに分かりやすくなりそう）。

それでは順番に見ていきましょう。まずはbinderドライバです。


